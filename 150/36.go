// 36. 有效的数独
/*
请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）


注意：
一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用 '.' 表示。

示例 1：
输入：board =
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true

示例 2：
输入：board =
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

提示：
board.length == 9
board[i].length == 9
board[i][j] 是一位数字（1-9）或者 '.'
*/
package main

import (
	"fmt"
	"lc/pkg"
)

func isValidSudoku(board [][]byte) bool {
	for i := 0; i < 9; i++ {
		for j := 0; j < 9; j++ {
			if board[i][j] < '1' || board[i][j] > '9' {
				continue
			}

			// 检查行
			for k := 0; k < 9; k++ {
				if k == i || (board[k][j] < '1' || board[k][j] > '9') {
					continue
				}
				if board[k][j] == board[i][j] {
					return false
				}
			}

			// 检查列
			for k := 0; k < 9; k++ {
				if k == j || (board[i][k] < '1' || board[i][k] > '9') {
					continue
				}
				if board[i][k] == board[i][j] {
					return false
				}
			}

			// 检查所属 3X3 区域
			// 首先确定左上角坐标，确定完左上角，右下角坐标只需要左上角横纵坐标 + 2 即可围成一个 3X3 区域
			leftTopX, leftTopY := 3*(i/3), 3*(j/3)
			rightBotX, rightBotY := leftTopX+2, leftTopY+2
			for a := leftTopX; a <= rightBotX; a++ {
				for b := leftTopY; b <= rightBotY; b++ {
					if (a == i && b == j) || (board[a][b] < '1' || board[a][b] > '9') {
						continue
					}

					if board[a][b] == board[i][j] {
						return false
					}
				}
			}
		}
	}
	return true
}

// 奇特的思路：使用位运算来标记数字是否出现过，从而判断是否有效。
func isValidSudokuBest(board [][]byte) bool {
	var row [9]int    // row[i] 行 i 出现的数字标记
	var col [9]int    // col[j] 列 j 出现的数字标记
	var box [3][3]int // box[i][j] 宫 i,j 出现的数字标记，每个 3x3 以左上角坐标进行标记

	for i := 0; i < 9; i++ {
		for j := 0; j < 9; j++ {
			if board[i][j] == '.' {
				continue
			}

			shiftNum := 1 << (board[i][j] - '0')
			if row[i]&shiftNum != 0 || col[j]&shiftNum != 0 || box[i/3][j/3]&shiftNum != 0 {
				return false
			}

			row[i] |= shiftNum
			col[j] |= shiftNum
			box[i/3][j/3] |= shiftNum
		}
	}
	return true
}

// Test Case1:
/*
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
*/
// Output: true

// Test Case2:
/*
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
*/
// Output: false
func main() {
	board := pkg.CreateSlice2D[byte]()
	fmt.Println(isValidSudoku(board))
}
